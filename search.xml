<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>滑动窗口思想</title>
      <link href="/2020/03/06/jing-dian-hua-dong-chuang-kou-si-xiang/"/>
      <url>/2020/03/06/jing-dian-hua-dong-chuang-kou-si-xiang/</url>
      
        <content type="html"><![CDATA[<p>这是一道LeetCode上的题目，我觉得很典型，故在此处记录这种思想</p><p>题目说明:</p><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><h5 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h5><pre><code>输入:target = 9输出:[[2,3,4],[4,5]]</code></pre><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><pre><code>输入:target = 15输出:[[1,2,3,4,5],[4,5,6][7,8]]</code></pre><h4 id="暴力法："><a href="#暴力法：" class="headerlink" title="暴力法："></a>暴力法：</h4><p>两次遍历，遍历到(target/2)+1即可</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findContinuousSequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>target<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            tmp_num <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>                tmp_num <span class="token operator">+=</span> j                <span class="token keyword">if</span> tmp_num <span class="token operator">></span> target<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                <span class="token keyword">elif</span> tmp_num <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                    tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>执行用时：<strong>568 ms</strong></p><p>内存消耗：<strong>13.5 MB</strong></p><p>当然，这题如果只是做出来而已，那么就失去了这题的意义，下面的思想是经常用到的。</p><h4 id="滑动窗口法："><a href="#滑动窗口法：" class="headerlink" title="滑动窗口法："></a>滑动窗口法：</h4><p>滑动窗口一般都会带着双指针，将窗口的两侧用双指针来实现。</p><p>由于最大窗口不能过半，故滑动窗口只取到(target / 2)+1，主要思想就是窗口的两端就是两个指针，若整个窗口的值大于或小于期望值target，就将窗口缩小，可以从左边或者右边缩小，只是效率不一样，我的代码方案如下：</p><p><strong>计算滑动窗口值用的数学归纳法，提升效率，若整个窗口的值大于或小于期望值target，则将右边窗口（指针）向左移一位，如果整个窗口的值小于或等于期望值，则将这个窗口整体向右平移一位（左指针，右指针个向右移动一位），代码如下：</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findContinuousSequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        left <span class="token operator">=</span> <span class="token number">1</span>        right <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> target <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">:</span>            tmp_num <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                tmp_num <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                tmp_num <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> tmp_num <span class="token operator">></span> target<span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> tmp_num <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> tmp_num <span class="token operator">==</span> target<span class="token punctuation">:</span>                tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><p>执行用时：<strong>232 ms</strong></p><p>内存消耗：<strong>13.4 MB</strong></p><p>相比于暴力法，时间优化一半以上，空间微微优化。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯思想</title>
      <link href="/2020/03/03/jing-dian-hui-su-si-xiang/"/>
      <url>/2020/03/03/jing-dian-hui-su-si-xiang/</url>
      
        <content type="html"><![CDATA[<p>回溯思想当然用全排列这个经典的题目，题目取自LeetCode：</p><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p><pre><code>输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><h4 id="回溯思想："><a href="#回溯思想：" class="headerlink" title="回溯思想："></a>回溯思想：</h4><p>回溯顾名思义就是科幻片的时光倒流，要是能重来，你会怎么做呢？现实中当然是不可能的事情，但是我们可以在算法中实现我的远大的理想。如果一个需求要求求解一定条件下所有可能解，那么第一时间就会想到回溯。</p><p>回溯通常伴随着递归，那是由于这类求解所有可能解的问题，本质上就是一个树，想要求解这个树的所有叶子结点，所以往往伴随深度优先搜索（DFS）的思想，就是回溯算法的第一个关键，当然，不可能求出所有的叶子结点，那样会有很多重复，所以“剪枝”就是回溯思想的第二个关键点，我们需要在合适的位置进行剪枝，以便我们可以只是求出我们所需要的答案，而不是所有答案。</p><p>本题首先，给定的是一个没有重复的数字序列，其次输出的是没有重复的全排列。直接上代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> sign <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> ans1<span class="token punctuation">,</span> sign<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*    * 定义一个回溯函数，用dfs表示，由于给定的nums数组需要用到，所以将此数组传入函数    * ans集合作为中间暂用的集合，在dfs搜索时，记录走过的路径    * sign作为数字用没用过的标识符    * depth就是树的深度    * out则是输出结果    */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sign<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> out<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*        * 无论是dfs还是递归思想，开始要设定“终点”，也就是递归的终止条件        * 条件就是当我们记录的数字个数等于给定数组的个数的时候，就将此数组加入结果集中        * 用Java来解其中关键的点是在结果集添加数组的时候，需要重新创建一个对象，如果没有，在回溯        * 的时候，会将记录的结果也“回溯”掉        */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        * 一个遍历中接一个递归，这是可以算是回溯算法的模板了        * 如果当前数字用过，那么当前数字对应的sign便为true，那么也不会往下继续执行        */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sign<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sign<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> ans<span class="token punctuation">,</span> sign<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*                * 这里为回溯算法的思想关键，递归回来之后，将之前改变的条件全部变回原来的情况                * 原来某一个数字是用过的，那么我将sign变回false，那么这个数字我没有用过                * 原来我将记录集合ans中添加了元素的，那么我将ans中移除一个元素                * 这就是体现的回溯思想！                */</span>                sign<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                ans<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>depth<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是！！！如果给定的数组是重复的呢？</p><pre><code>输入: [1,1,2]输出:[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre><p>其实和上面的思想是一样的，直接上代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sign <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里加一个排序，可以提升效率</span>        <span class="token function">helper</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> sign<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">helper</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sign<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> out<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        * 只需要这个添加一个记录值pre，这个pre记录我当前递归节点的上一个节点值，        * 如果递归节点值等于上一个节点，那么就直接跳过当前遍历        */</span>        <span class="token keyword">int</span> pre <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sign<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> pre <span class="token operator">!=</span> nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sign<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token function">helper</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> sign<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>                pre <span class="token operator">=</span> nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>                sign<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                ans<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>depth<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈List集合</title>
      <link href="/2019/10/03/map-in-java/"/>
      <url>/2019/10/03/map-in-java/</url>
      
        <content type="html"><![CDATA[<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>首先看下集合的结构图:</p><p><img src="/2019/10/03/map-in-java/img2.png" alt="Map结构图（图片来源于网络）"></p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><h4 id="第一层是迭代器Iterator接口。"><a href="#第一层是迭代器Iterator接口。" class="headerlink" title="第一层是迭代器Iterator接口。"></a>第一层是迭代器Iterator接口。</h4><h4 id="第二层是Collection接口继承Iterator。"><a href="#第二层是Collection接口继承Iterator。" class="headerlink" title="第二层是Collection接口继承Iterator。"></a>第二层是Collection接口继承Iterator。</h4><h4 id="第三层可以分为两大类：存的类型为值或键值对。"><a href="#第三层可以分为两大类：存的类型为值或键值对。" class="headerlink" title="第三层可以分为两大类：存的类型为值或键值对。"></a>第三层可以分为两大类：存的类型为值或键值对。</h4><h5 id="Value型"><a href="#Value型" class="headerlink" title="Value型"></a>Value型</h5><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>​            List类型的特点为有序（放入value是什么顺序，出来就是什么顺序），可重复，实现类有ArrayList，LinkedList和Vector，其中ArrayList和LinkedList的底层分别是根据数组和链表实现的，当然这两个实现类的特点也和数组和链表的特点一样，ArrayList改和查效率高，LinkedList增删效率高。vector用的比较少，它的特点是线程安全的，底层都是用synchronize锁实现的线程安全。</p><h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><p>​            Set集合类型的特点为无序（放入value是什么顺序，出来不一定是这个顺序），不可重复，实现类有HashSet，SortedSet接口继承Set接口，SortedSet的实现类是TreeSet。</p><p>​            HashSet其实就是HashMap的key，保证HashMap的key的唯一性。HashSet底层是用哈希表（数组+链表）的原理实现的。LinkedHashSet的底层是将哈希表的实现变为数组+双向链表，双向链表相比于单链表的优点就是双向链表更容易到达前一个节点，效率更高。</p><p>​            SortedSet是用TreeSet实现的，SortedSet顾名思义就是有序的Set集合。</p><h5 id="Key-Value"><a href="#Key-Value" class="headerlink" title="Key-Value"></a>Key-Value</h5><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p>​            由Key-Value结构，Key键值唯一，线程不安全的，底层也是哈希表（数组+链表+红黑树），HashSet的实现就是调用HashMap的方法，HashMap有个默认值，当链表长度大于这个默认值时，会将链表转为红黑树，小于默认值时，转化为链表，哈希表原理如下</p><p><img src="/2019/10/03/map-in-java/img1.png" alt="HashMap原理图（图片来源于网络）"></p><p>​                                                                                图片取自网络</p><p>JDK1.7和JDK1.8相比，1.7版本HashMap的结构是数组+链表结构，而1.8版本HashMap结构是数据+链表+红黑树，提升了效率。</p><h6 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h6><p>HashTable和HashMap相比只有很小的区别，第一HashTable是线程安全的，第二HashTable不能接受key或value为null的值。</p><h6 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h6><p>TreeMap是SortedMap的实现类，SortedMap对其键上进行了排序的Map集合。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
